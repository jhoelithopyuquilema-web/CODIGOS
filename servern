const WebSocket = require('ws');
const { SocksProxyAgent } = require('socks-proxy-agent');
const fs = require('fs');

// --- 1. LECTORES Y ESCRITORES (El idioma de Agar.io) ---
class Reader {
    constructor(buffer) {
        this.dataView = new DataView(buffer);
        this.byteOffset = 0;
    }
    readUint8() { return this.dataView.getUint8(this.byteOffset++); }
    readUint32() { const value = this.dataView.getUint32(this.byteOffset, true); this.byteOffset += 4; return value; }
    readString() {
        let result = ""; let charCode;
        while ((charCode = this.readUint8()) !== 0) { result += String.fromCharCode(charCode); }
        return result;
    }
}

class Writer {
    constructor(size = 100) {
        this.dataView = new DataView(new ArrayBuffer(size));
        this.byteOffset = 0;
    }
    ensureCapacity(additionalSize) {
        if (this.byteOffset + additionalSize > this.dataView.buffer.byteLength) {
            const newBuffer = new ArrayBuffer(this.dataView.buffer.byteLength * 2);
            new Uint8Array(newBuffer).set(new Uint8Array(this.dataView.buffer));
            this.dataView = new DataView(newBuffer);
        }
    }
    writeUint8(value) { this.ensureCapacity(1); this.dataView.setUint8(this.byteOffset++, value); }
    writeUint16(value) { this.ensureCapacity(2); this.dataView.setUint16(this.byteOffset, value, true); this.byteOffset += 2; }
    writeInt32(value) { this.ensureCapacity(4); this.dataView.setInt32(this.byteOffset, value, true); this.byteOffset += 4; }
    writeUint32(value) { this.ensureCapacity(4); this.dataView.setUint32(this.byteOffset, value, true); this.byteOffset += 4; }
    writeString(str) {
        this.ensureCapacity(str.length + 1);
        for (let i = 0; i < str.length; i++) { this.writeUint8(str.charCodeAt(i)); }
        this.writeUint8(0);
    }
    toBuffer() { return this.dataView.buffer.slice(0, this.byteOffset); }
}

// --- 2. CARGAR PROXIES ---
let proxies = [];
try {
    proxies = fs.readFileSync('proxies.txt', 'utf8').split('\n').filter(p => p.trim() !== '');
    console.log(`‚úÖ Cargados ${proxies.length} proxies SOCKS4.`);
} catch (e) {
    console.log("‚ö†Ô∏è No se encontr√≥ proxies.txt - Los bots se conectar√°n SIN proxy (desde tu IP)");
    // Si no hay proxies, usamos null para conectar directamente
    proxies = [null];
}

let targetX = 0, targetY = 0;
let currentAgarServer = null;
let botsActivos = 0;
let ataqueIniciado = false;
let ejercitoBots = [];
let botAiMode = false;
let vShieldMode = false;

// --- 3. EL CLON DEL BOT (Con encriptaci√≥n Murmur2) ---
class BotNode {
    constructor(proxyIP, serverUrl, botName = 'ISOLATED ECU') {
        this.proxyIP = proxyIP;
        this.serverUrl = serverUrl;
        this.ws = null;
        this.encryptionKey = 0;
        this.decryptionKey = 0;
        this.clientVersion = 31116;
        this.protocolVersion = 23;
        this.name = botName;
        this.isAlive = false;
        this.connect();
    }

    connect() {
        try {
            const options = {
                headers: {
                    'Origin': 'https://agar.io',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                }
            };

            // Si hay proxy, lo usamos
            if (this.proxyIP) {
                options.agent = new SocksProxyAgent(`socks4://${this.proxyIP}`);
            }

            this.ws = new WebSocket(this.serverUrl, options);
            this.ws.binaryType = "arraybuffer";

            this.ws.on('open', () => {
                botsActivos++;
                console.log(`üü¢ Bot conectado ${this.proxyIP ? `(proxy: ${this.proxyIP})` : '(directo)'} | Total: ${botsActivos}`);
                this.sendProtocolVersion();
                this.sendClientVersion();
            });

            this.ws.on('message', (msg) => {
                try {
                    // CR√çTICO: Convertir Buffer de Node.js a ArrayBuffer correctamente
                    let buffer;
                    if (msg instanceof ArrayBuffer) {
                        buffer = msg;
                    } else if (Buffer.isBuffer(msg)) {
                        // Convertir Buffer a ArrayBuffer
                        buffer = msg.buffer.slice(msg.byteOffset, msg.byteOffset + msg.byteLength);
                    } else {
                        buffer = new Uint8Array(msg).buffer;
                    }
                    
                    // Desencriptar si es necesario
                    if (this.decryptionKey) {
                        buffer = this.xorBuffer(buffer, this.decryptionKey ^ this.clientVersion);
                    }
                    
                    this.handleBuffer(buffer);
                } catch (e) {
                    console.error(`‚ùå Error procesando mensaje: ${e.message}`);
                }
            });

            this.ws.on('close', () => {
                botsActivos--;
                console.log(`üî¥ Bot desconectado | Restantes: ${botsActivos}`);
                ejercitoBots = ejercitoBots.filter(b => b !== this);
            });
            
            this.ws.on('error', (err) => { 
                console.log(`‚ùå Error en bot: ${err.message}`);
            });
        } catch (e) {
            console.log(`‚ùå Error conectando bot: ${e.message}`);
        }
    }

    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            if (this.encryptionKey) {
                data = this.xorBuffer(data, this.encryptionKey);
                this.encryptionKey = this.rotateKey(this.encryptionKey);
            }
            this.ws.send(Buffer.from(data));
        }
    }

    handleBuffer(buffer) {
        const reader = new Reader(buffer);
        const opcode = reader.readUint8();
        
        if (opcode === 241) {
            this.decryptionKey = reader.readUint32();
            const serverVersion = reader.readString();
            const match = this.serverUrl.match(/wss:\/\/(web-arenas-live-[\w-]+\.agario\.miniclippt\.com\/[\w-]+\/[\d-]+)/);
            if (match) {
                this.encryptionKey = this.murmur2(match[1] + serverVersion, 255);
            }
        } else if (opcode === 242) {
            this.sendSpawn();
        } else if (opcode === 32) {
            this.isAlive = true;
            console.log(`‚úÖ Bot VIVO en el juego!`);
        }
    }

    sendProtocolVersion() {
        const writer = new Writer(5); 
        writer.writeUint8(254); 
        writer.writeUint32(this.protocolVersion);
        if (this.ws) this.ws.send(Buffer.from(writer.toBuffer()));
    }

    sendClientVersion() {
        const writer = new Writer(5); 
        writer.writeUint8(255); 
        writer.writeUint32(this.clientVersion);
        if (this.ws) this.ws.send(Buffer.from(writer.toBuffer()));
    }

    sendSpawn() {
        const writer = new Writer(this.name.length * 3); 
        writer.writeUint8(0); 
        writer.writeString(this.name);
        this.send(Buffer.from(writer.toBuffer()));
    }

    moveTo(x, y) {
        if (!this.isAlive) return;
        const writer = new Writer(13);
        writer.writeUint8(16);
        writer.writeInt32(x);
        writer.writeInt32(y);
        writer.writeUint32(this.decryptionKey);
        this.send(Buffer.from(writer.toBuffer()));
    }

    rotateKey(key) {
        key = Math.imul(key, 1540483477) >> 0;
        key = Math.imul(key >>> 24 ^ key, 1540483477) >> 0 ^ 114296087;
        key = Math.imul(key >>> 13 ^ key, 1540483477) >> 0;
        return key >>> 15 ^ key;
    }

    xorBuffer(buffer, key) {
        // Asegurarse de que buffer es un ArrayBuffer
        const arrayBuffer = buffer instanceof ArrayBuffer ? buffer : buffer.buffer;
        const dataView = new DataView(arrayBuffer);
        
        for (let i = 0; i < dataView.byteLength; i++) { 
            dataView.setUint8(i, dataView.getUint8(i) ^ key >>> i % 4 * 8 & 255); 
        }
        
        return arrayBuffer;
    }

    murmur2(str, seed) {
        let length = str.length; 
        let h = seed ^ length; 
        let i = 0;
        while (length >= 4) {
            let k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
            k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
            k ^= k >>> 24; 
            k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
            h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16) ^ k;
            length -= 4; 
            ++i;
        }
        switch (length) {
            case 3: h ^= (str.charCodeAt(i + 2) & 255) << 16;
            case 2: h ^= (str.charCodeAt(i + 1) & 255) << 8;
            case 1: h ^= str.charCodeAt(i) & 255; 
                h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
        }
        h ^= h >>> 13; 
        h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16); 
        h ^= h >>> 15;
        return h >>> 0;
    }
}

// --- 4. SERVIDOR DE COMUNICACI√ìN CON TAMPERMONKEY ---
console.log(`üöÄ Iniciando servidor WebSocket en puerto 8080...`);
const wss = new WebSocket.Server({ 
    port: 8080,
    host: '0.0.0.0' // IMPORTANTE: Escuchar en todas las interfaces
});

console.log(`‚úÖ Servidor escuchando en ws://0.0.0.0:8080`);
console.log(`üì° Esperando conexi√≥n desde Tampermonkey...`);

wss.on('connection', (ws, req) => {
    const clientIP = req.socket.remoteAddress;
    console.log(`üîµ ¬°CONECTADO! Cliente desde: ${clientIP}`);
    
    ws.on('message', (msg) => {
        try {
            const data = JSON.parse(msg);
            
            // Actualizar modos
            if (data.botAi !== undefined) {
                botAiMode = data.botAi;
                console.log(`üß† Modo AI: ${botAiMode ? 'ACTIVADO' : 'DESACTIVADO'}`);
            }
            
            if (data.vShield !== undefined) {
                vShieldMode = data.vShield;
                console.log(`üõ°Ô∏è VShield: ${vShieldMode ? 'ACTIVADO' : 'DESACTIVADO'}`);
            }
            
            // Actualizar coordenadas del mouse
            if (data.x !== undefined && data.y !== undefined) {
                targetX = data.x; 
                targetY = data.y;
                
                // Mover todos los bots vivos seg√∫n el modo
                let botsMoved = 0;
                ejercitoBots.forEach(bot => {
                    if (bot.isAlive) {
                        bot.moveTo(targetX, targetY);
                        botsMoved++;
                    }
                });
                
                if (botsMoved > 0 && Date.now() % 5000 < 100) { // Log cada 5 segundos
                    console.log(`üéØ ${botsMoved} bots activos | AI:${botAiMode?'ON':'OFF'} Shield:${vShieldMode?'ON':'OFF'}`);
                }
            }

            // Iniciar ataque
            if (data.start && data.server && !ataqueIniciado) {
                ataqueIniciado = true;
                currentAgarServer = data.server;
                const botName = data.botName || 'ISOLATED ECU';
                console.log(`\nüî• ¬°ORDEN RECIBIDA!`);
                console.log(`üì° Servidor: ${currentAgarServer}`);
                console.log(`ü§ñ Bots: ${data.botCount || 200}`);
                console.log(`üìù Nombre: ${botName}`);
                console.log(`üß† AI: ${botAiMode ? 'ON' : 'OFF'}`);
                console.log(`üõ°Ô∏è Shield: ${vShieldMode ? 'ON' : 'OFF'}`);
                iniciarEjercito(data.botCount || 200, botName);
            }
            
            // Detener ataque
            if (data.start === false && ataqueIniciado) {
                ataqueIniciado = false;
                console.log("\nüõë Deteniendo todos los bots...");
                ejercitoBots.forEach(bot => { 
                    if(bot.ws) bot.ws.close(); 
                });
                ejercitoBots = [];
                botsActivos = 0;
                console.log("‚úÖ Todos los bots eliminados");
            }
        } catch (e) {
            console.error(`‚ùå Error procesando mensaje: ${e.message}`);
        }
    });

    ws.on('close', () => {
        console.log("üî¥ Cliente de Tampermonkey desconectado");
    });

    ws.on('error', (err) => {
        console.error(`‚ùå Error en WebSocket: ${err.message}`);
    });
});

function iniciarEjercito(cantidadBots = 200, botName = 'ISOLATED ECU') {
    let proxyIndex = 0;
    let botsCreados = 0;
    
    console.log(`\n‚öîÔ∏è Iniciando creaci√≥n de ${cantidadBots} bots...`);
    
    const creadorInterval = setInterval(() => {
        if (!ataqueIniciado || botsCreados >= cantidadBots) {
            clearInterval(creadorInterval);
            console.log(`\n‚úÖ Creaci√≥n completada: ${botsCreados} bots lanzados`);
            return;
        }
        
        const proxy = proxies[proxyIndex];
        const nuevoBot = new BotNode(proxy, currentAgarServer, botName);
        ejercitoBots.push(nuevoBot);
        botsCreados++;
        
        proxyIndex++;
        if (proxyIndex >= proxies.length) proxyIndex = 0;
        
        // Mostrar progreso cada 10 bots
        if (botsCreados % 10 === 0) {
            console.log(`üìà Progreso: ${botsCreados}/${cantidadBots} bots creados`);
        }
    }, 150);
}

// Manejar errores globales
process.on('uncaughtException', (err) => {
    console.error(`‚ùå Error no capturado: ${err.message}`);
});

process.on('unhandledRejection', (err) => {
    console.error(`‚ùå Promesa rechazada: ${err.message}`);
});

console.log(`\nüí° INSTRUCCIONES:`);
console.log(`1. Aseg√∫rate de que el puerto 8080 est√° abierto en tu firewall`);
console.log(`2. En el script de Tampermonkey, actualiza la IP a la de este servidor Ubuntu`);
console.log(`3. Crea el archivo 'proxies.txt' con proxies SOCKS4 (uno por l√≠nea) o d√©jalo vac√≠o para usar tu IP`);
console.log(`4. Abre Agar.io y presiona Start en el panel`);
console.log(`\nüéÆ ¬°Listo para recibir bots!\n`);
