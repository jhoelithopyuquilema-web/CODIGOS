const WebSocket = require('ws');
const { SocksProxyAgent } = require('socks-proxy-agent');
const fs = require('fs');

// --- 1. LECTORES Y ESCRITORES (El idioma de Agar.io) ---
class Reader {
    constructor(buffer) {
        const arrayBuffer = buffer instanceof ArrayBuffer ? buffer : buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
        this.dataView = new DataView(arrayBuffer);
        this.byteOffset = 0;
    }
    readUint8() { return this.dataView.getUint8(this.byteOffset++); }
    readUint16() { const value = this.dataView.getUint16(this.byteOffset, true); this.byteOffset += 2; return value; }
    readInt32() { const value = this.dataView.getInt32(this.byteOffset, true); this.byteOffset += 4; return value; }
    readUint32() { const value = this.dataView.getUint32(this.byteOffset, true); this.byteOffset += 4; return value; }
    readString() {
        let result = ""; let charCode;
        while ((charCode = this.readUint8()) !== 0) { result += String.fromCharCode(charCode); }
        return result;
    }
}

class Writer {
    constructor(size = 100) {
        this.dataView = new DataView(new ArrayBuffer(size));
        this.byteOffset = 0;
    }
    ensureCapacity(additionalSize) {
        if (this.byteOffset + additionalSize > this.dataView.buffer.byteLength) {
            const newBuffer = new ArrayBuffer(this.dataView.buffer.byteLength * 2);
            new Uint8Array(newBuffer).set(new Uint8Array(this.dataView.buffer));
            this.dataView = new DataView(newBuffer);
        }
    }
    writeUint8(value) { this.ensureCapacity(1); this.dataView.setUint8(this.byteOffset++, value); }
    writeUint16(value) { this.ensureCapacity(2); this.dataView.setUint16(this.byteOffset, value, true); this.byteOffset += 2; }
    writeInt32(value) { this.ensureCapacity(4); this.dataView.setInt32(this.byteOffset, value, true); this.byteOffset += 4; }
    writeUint32(value) { this.ensureCapacity(4); this.dataView.setUint32(this.byteOffset, value, true); this.byteOffset += 4; }
    writeString(str) {
        this.ensureCapacity(str.length + 1);
        for (let i = 0; i < str.length; i++) { this.writeUint8(str.charCodeAt(i)); }
        this.writeUint8(0);
    }
    toBuffer() { return Buffer.from(this.dataView.buffer.slice(0, this.byteOffset)); }
}

// --- 2. CARGAR PROXIES ---
let proxies = [];
try {
    proxies = fs.readFileSync('proxies.txt', 'utf8').split('\n').filter(p => p.trim() !== '');
    console.log(`âœ… Cargados ${proxies.length} proxies SOCKS4.`);
} catch (e) {
    console.log("âš ï¸ No se encontrÃ³ proxies.txt - Los bots se conectarÃ¡n SIN proxy.");
    proxies = [null];
}

let currentAgarServer = null;
let botsActivos = 0;
let ataqueIniciado = false;
let ejercitoBots = [];

// --- 3. EL CLON DEL BOT ---
class BotNode {
    constructor(proxyIP, serverUrl, botName = 'ISOLATED ECU') {
        this.proxyIP = proxyIP;
        this.serverUrl = serverUrl;
        this.ws = null;
        this.encryptionKey = 0;
        this.decryptionKey = 0;
        this.clientVersion = 31116;
        this.protocolVersion = 23;
        this.name = botName;
        this.isAlive = false;
        this.connect();
    }

    connect() {
        try {
            const options = {
                headers: {
                    'Origin': 'https://agar.io',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
            };
            if (this.proxyIP) options.agent = new SocksProxyAgent(`socks4://${this.proxyIP}`);

            this.ws = new WebSocket(this.serverUrl, options);
            this.ws.binaryType = "arraybuffer";

            this.ws.on('open', () => {
                botsActivos++;
                this.sendProtocolVersion();
                this.sendClientVersion();
            });

            this.ws.on('message', (msg) => {
                try {
                    let buffer;
                    if (msg instanceof ArrayBuffer) buffer = msg;
                    else if (Buffer.isBuffer(msg)) buffer = msg.buffer.slice(msg.byteOffset, msg.byteOffset + msg.byteLength);
                    else buffer = new Uint8Array(msg).buffer;
                    
                    if (this.decryptionKey) buffer = this.xorBuffer(buffer, this.decryptionKey ^ this.clientVersion);
                    this.handleBuffer(buffer);
                } catch (e) {}
            });

            this.ws.on('close', () => {
                botsActivos--;
                this.isAlive = false;
                ejercitoBots = ejercitoBots.filter(b => b !== this);
            });
            this.ws.on('error', () => {});
        } catch (e) {}
    }

    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            if (this.encryptionKey) {
                data = this.xorBuffer(data, this.encryptionKey);
                this.encryptionKey = this.rotateKey(this.encryptionKey);
            }
            this.ws.send(Buffer.from(data));
        }
    }

    handleBuffer(buffer) {
        const reader = new Reader(buffer);
        const opcode = reader.readUint8();
        
        if (opcode === 241) {
            this.decryptionKey = reader.readUint32();
            const serverVersion = reader.readString();
            const match = this.serverUrl.match(/wss:\/\/(web-arenas-live-[\w-]+\.agario\.miniclippt\.com\/[\w-]+\/[\d-]+)/);
            if (match && match[1]) this.encryptionKey = this.murmur2(match[1] + serverVersion, 255);
            else this.encryptionKey = this.murmur2("agario" + serverVersion, 255);
        } else if (opcode === 242) {
            this.sendSpawn();
        } else if (opcode === 32) {
            this.isAlive = true;
        }
    }

    sendProtocolVersion() {
        const writer = new Writer(5); 
        writer.writeUint8(254); writer.writeUint32(this.protocolVersion);
        this.send(writer.toBuffer());
    }

    sendClientVersion() {
        const writer = new Writer(5); 
        writer.writeUint8(255); writer.writeUint32(this.clientVersion);
        this.send(writer.toBuffer());
    }

    sendSpawn() {
        const writer = new Writer(this.name.length * 3); 
        writer.writeUint8(0); writer.writeString(this.name);
        this.send(writer.toBuffer());
    }

    // --- COMANDOS DE ACCIÃ“N ---
    moveTo(x, y) {
        if (!this.isAlive) return;
        const writer = new Writer(13);
        writer.writeUint8(16);
        writer.writeInt32(x);
        writer.writeInt32(y);
        writer.writeUint32(this.decryptionKey); 
        this.send(writer.toBuffer());
    }

    split() {
        if (!this.isAlive) return;
        const writer = new Writer(1);
        writer.writeUint8(17); 
        this.send(writer.toBuffer());
    }

    eject() {
        if (!this.isAlive) return;
        const writer = new Writer(1);
        writer.writeUint8(21); 
        this.send(writer.toBuffer());
    }
    // --------------------------

    rotateKey(key) {
        key = Math.imul(key, 1540483477) >> 0;
        key = Math.imul(key >>> 24 ^ key, 1540483477) >> 0 ^ 114296087;
        key = Math.imul(key >>> 13 ^ key, 1540483477) >> 0;
        return key >>> 15 ^ key;
    }

    xorBuffer(buffer, key) {
        const arrayBuffer = buffer instanceof ArrayBuffer ? buffer : buffer.buffer;
        const dataView = new DataView(arrayBuffer);
        for (let i = 0; i < dataView.byteLength; i++) { 
            dataView.setUint8(i, dataView.getUint8(i) ^ key >>> i % 4 * 8 & 255); 
        }
        return arrayBuffer;
    }

    murmur2(str, seed) {
        let length = str.length; let h = seed ^ length; let i = 0;
        while (length >= 4) {
            let k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
            k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
            k ^= k >>> 24; k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
            h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16) ^ k;
            length -= 4; ++i;
        }
        switch (length) {
            case 3: h ^= (str.charCodeAt(i + 2) & 255) << 16;
            case 2: h ^= (str.charCodeAt(i + 1) & 255) << 8;
            case 1: h ^= str.charCodeAt(i) & 255; h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
        }
        h ^= h >>> 13; h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16); h ^= h >>> 15;
        return h >>> 0;
    }
}

// --- 4. SERVIDOR DE COMUNICACIÃ“N ---
console.log(`ðŸš€ Iniciando Servidor WebSocket en puerto 8080...`);
const wss = new WebSocket.Server({ port: 8080, host: '0.0.0.0' });

wss.on('connection', (ws) => {
    console.log(`ðŸ”µ Control de Tampermonkey Conectado.`);
    
    ws.on('message', (msg) => {
        try {
            const data = JSON.parse(msg);

            // EJECUTAR COMANDOS (X = Split, C = Eject)
            if (data.action === 'split') {
                ejercitoBots.forEach(bot => { if (bot && bot.isAlive && bot.ws && bot.ws.readyState === 1) bot.split(); });
                return;
            }
            if (data.action === 'eject') {
                ejercitoBots.forEach(bot => { if (bot && bot.isAlive && bot.ws && bot.ws.readyState === 1) bot.eject(); });
                return;
            }
            
            // MOVIMIENTO ANTI-GHOSTING
            if (data.x !== undefined && data.y !== undefined) {
                const baseX = Math.round(data.x); 
                const baseY = Math.round(data.y);
                
                ejercitoBots.forEach(bot => {
                    if (bot && bot.isAlive && bot.ws && bot.ws.readyState === 1) {
                        try {
                            const offsetX = Math.floor(Math.random() * 80) - 40; 
                            const offsetY = Math.floor(Math.random() * 80) - 40;
                            bot.moveTo(baseX + offsetX, baseY + offsetY);
                        } catch (err) {}
                    }
                });
            }

            // INICIO Y FIN DEL EJÃ‰RCITO
            if (data.start && data.server && !ataqueIniciado) {
                ataqueIniciado = true;
                currentAgarServer = data.server;
                const botName = data.botName || 'ISOLATED ECU';
                console.log(`\nðŸ”¥ Â¡ATAQUE INICIADO! Servidor: ${currentAgarServer}`);
                iniciarEjercito(data.botCount || 150, botName);
            }
            
            if (data.start === false && ataqueIniciado) {
                ataqueIniciado = false;
                console.log("\nðŸ›‘ Deteniendo...");
                ejercitoBots.forEach(bot => { if(bot.ws) bot.ws.close(); });
                ejercitoBots = [];
            }
        } catch (e) {}
    });
});

function iniciarEjercito(cantidadBots, botName) {
    let proxyIndex = 0;
    let botsCreados = 0;
    
    const creadorInterval = setInterval(() => {
        if (!ataqueIniciado || botsCreados >= cantidadBots) {
            clearInterval(creadorInterval);
            console.log(`âœ… Todos los bots lanzados.`);
            return;
        }
        const proxy = proxies[proxyIndex] || null;
        ejercitoBots.push(new BotNode(proxy, currentAgarServer, botName));
        botsCreados++;
        proxyIndex++;
        if (proxyIndex >= proxies.length) proxyIndex = 0;
    }, 150);
}

process.on('uncaughtException', () => {});
process.on('unhandledRejection', () => {});

console.log(`\nðŸŽ® Â¡Listo! Esperando conexiÃ³n desde Agar.io...\n`);
